.. 2020/01

scrolling - is this the job of the terminal emulator,
or for a separate tool?

not sure. 
Ok. I try to break this down - 
it's also the question, whether one likes to have (graphical) scrollbars.

.. 2020/01/06

Patched the existing scrollback patch in.
I did find a terminal scroller, and somehow this would be nicer.
This would be more consistent, despite what terminal or -emulation
is used. But this thing slowed down st quite a bit.

Ok. At the moment, the ripped unicode and rgb support
really show some effect.
But the scrollback patch somehow is quite memory consuming.

Possibly I should either come back to the terminal scroller,
and see, whether this thing could be optimized for better speed.
Or, the scrollback buffer within st is, well, not exactly 
well dessigned. It's a static buffer,
even the variable is made globally static.
so. For me, always keeping at least 10 terminals open,
that's not so good.
Have to look at it.

For now I'll upload my changes, again.
And it seems, like I should do a real fork of st.

I already changed quite a bit, and merging all my changes
might be too much work.
We'll see.

..


Thinking about it - it might be better keeping the scrollback
buffer within st. The problems arising by separating the scrollback 
would be, especially: 
- Ansi control characters either being resent when scrolling back,
	or they would have to be parsed
- Color codes and textattributes, same problem;
	worse, when scrolling back they would have to be parsed again.
- this also prevents the scrollback from being accordingly seekable

However, something is bloating st, when setting the scrollback buffer
to larger values (>10k lines)

Ok. So. Found it. It's obvious.
The history within st needs to keep track of every glyph,
meaning not only the displayed chars, with it's attributes, 
but also the "empty" Glyphs. (Which also do have attributes, 
e.g. the backgroundcolor.

So. What to do. 
An external scrollback buffer has the advantage, 
of holding only chars, which are displayed, and control sequences.
But - e.g., when scrolling backwards, there might be colors
and text attributes displayed wrong.
Copying also could give problems.
Either the control sequences are parsed within st AND the external scrollback.
or. :/ dunno. I like a colored scrollback buffer.

Seems I should see, whether I'm able to optimize the scrollback buffer
of st. 
The current implementation: 
  - allocates a complete line of glyphs
  - for every single line. Does this even for completely empty, 
    or yet unusedlines.
  - reallocates every single line of the "history" on win resize
	- The "history" is more like a preallocated buffer, 
	  where scrolled lines are copied into.

So. Instead of doing this, I'm now going to prepare 0.9rc1.
There still is some utf8 stuff left to clean.
And further testing would be useful.

About adding patches, and so on: When you guard your changes 
with an #ifdef YOURPATCHNAME / #endif, 
I'll add patches in each case. 
Just do a fork, and consequently file a pull request. 

You can grep for the switch "XRESOURCES",
where I did exactly this, guard a patch 
to be optional.

;) It's also your showcase, bookmarks, about what you added.

---

copied this from README. Its irrelevant.


A rant against some sort of scientists, btw.
So, someone is sure, and "prooves" this 
by a study, humans cannot perceipt a latency &lower 200ms,
since that's our reaction time. 

That's. Bullshit. 
One can think, what this scientist did believe.
But - just ask an musician. A system, used for plaing live e.g. synthesizer,
is really hard to play with a latency of 200ms. 

I'd say, it's going to be hard to get a medium timing with anything bigger than 40ms.

The latency is feelable at, say, 5ms. at least. I did never really check,
since even 20ms are hard to get with nowadays systems.
But you can tell, in each case, the difference to a "real" instrument. 
Which also doe's have some latency. But, amongst others, this latency is steady.

Oh. There's another example, showing this scientist being wrong. 
It's our capability to perceive the location of an audible source.
What needs a perception and combination of both ears in the scale of microseconds.
Maybe even nanoseconds. But 200ms is. Painful slow.


